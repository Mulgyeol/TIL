---
description: 투 포인터와 슬라이딩 윈도우
date: 2021-06-24
tags: ["Algorithm"]
---

# 투 포인터와 슬라이딩 윈도우

![img](../images/Algorithm.png)

이 두 알고리즘은 선형 공간(1차원 배열)을 2회 이상 반복적으로 탐색해야 할 경우 O(N^2) 이상 걸릴 시간 복잡도를 부분 배열을 활용하여 O(N)으로 줄일 수 있다는 공통점이 있다.

차이점은, `부분 배열 길이의 변화`이다.
투포인터 알고리즘은 부분 배열의 길이가 가변적이지만,
슬라이딩 위도우 알고리즘은 부분 배열의 길이가 고정적이다.

## 투 포인터

- 투포인터 알고리즘에는 2개의 포인터 변수를 사용하는데, `left`, `right`를 주로 사용한다.
  - 혹은 `start`와 `end`를 사용하기도 한다.
- `left`는 배열에서 부분 배열의 시작 인덱스를 가리킨다.
- `right`는 배열에서 부분 배열의 끝 인덱스를 가리킨다.
- 부분배열이 변할 때마다, left와 right 값에 변화를 주면서 탐색을 해나간다.

## 투포인터의 시작 위치 배치

투 포인터에서 시작 위치 배치방법은 2가지가 있다.

1. 둘 다 첫번째 원소에서 시작하는 경우(같은 진행방향)
2. 배열의 첫번째 원소와 배열의 마지막 원소에서 시작하는 경우(반대 진행방향)

## 예시

- 배열 arr = [1,2,3,4,2,5,3,1,1,2] 에서 구간이 합이 5인 것의 경우의 수를 구해라.
- right를 우측으로 하나씩 옮기면서 arr[left] + ... + arr[right]의 값이 5보다 크다면 더이상 right를 우측으로 옮기는건 무의미하다. right를 우측으로 옮겨봤자 마찬가지로 5보다 크기 때문이다. 따라서, 이 경우 left를 우측으로 옮긴다.

```java
public class Main {

    public static void main(String[] args) {
        int[] arr = {1, 2, 3, 4, 2, 5, 3, 1, 1, 2}; // 크기가 10인 1차원 배열
        int m = 5; // 연속된 구간의 합이 5인 경우를 찾는다.

        int count = twoPointers(arr, m);
    }

    private static int twoPointers(int[] arr, int m) {
        int sum = 0, count = 0;
        int left = 0, right = 0;

        while (true) {
            if (sum > m) { // 1. left를 우측으로 옮기는 경우
                sum -= arr[left++];
            } else if (right == arr.length - 1) { // right를 우측으로 옮기기 전에 배열의 끝을 가리키는지 확인한다.
                break;
            } else { // 2. right를 우측으로 옮기는 경우
                sum += arr[right++];
            }

            if (sum == m) count++;
        }

        return count;
    }
}

```

## 슬라이딩 윈도우 알고리즘

- 배열 [1, 5, 22, 3, 6, 30, 6, 25, 11, 0] 에서 길이가 3인 서브배열의 합계가 가장 큰 서브배열은 무엇인가? 같은 문제에서 사용될 수 있다.
- 이름에서 알 수 있듯, 고정길이의 부분배열(윈도우)가 이동하면서 같은 구간을 탐색한다.
- 윈도우가 이동할 때마다, 부분 배열에서 빠진 인덱스와 추가된 인덱스의 값을 처리해준다.
